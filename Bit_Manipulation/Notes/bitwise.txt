OR Operation  (|): add two bits 
AND Operation (&): multiply two bits
XOR Operation (^): if two bits are same ans is 0 else 1
NOT Operation (~): opposite bit
Left Shift Operation (<<): left shift bits and add 0 at end (it is always multiple of 2)
Right Shift Operation (>>): right shift bits so the first bit gets disappear and we 0 at the end

Precedence: ~ (Highest), <<>>, &, ^, | (lowest)


| Operator    | Symbol | Meaning                 | Example                       |    |         |                |
| ----------- | ------ | ----------------------- | ----------------------------- | -- | ------- | -------------- |
| AND         | `&`    | 1 if both bits are 1    | `5 & 3 â†’ 101 & 011 = 001 (1)` |    |         |                |
| OR          | `      | `                       | 1 if any bit is 1             | `5 | 3 â†’ 101 | 011 = 111 (7)` |
| XOR         | `^`    | 1 if bits are different | `5 ^ 3 â†’ 101 ^ 011 = 110 (6)` |    |         |                |
| NOT         | `~`    | Inverts bits            | `~5 â†’ -(5+1) = -6`            |    |         |                |
| Left Shift  | `<<`   | Moves bits left         | `5 << 1 â†’ 1010 (10)`          |    |         |                |
| Right Shift | `>>`   | Moves bits right        | `5 >> 1 â†’ 10 (2)`             |    |         |                |


================================= âš¡ Step 3: Bit Tricks Youâ€™ll Use in DSA  ========================================

ğŸŸ¢ 1ï¸âƒ£ Check if a number is even or odd

Idea: Look at the last bit

If last bit = 1 â†’ odd

If last bit = 0 â†’ even


def is_odd(n):
    return n & 1 == 1

print(is_odd(5))  # True
print(is_odd(8))  # False



ğŸŸ¢ 2ï¸âƒ£ Get the ith bit of a number

To check if the ith bit is 1 or 0
  
ğŸ§© Formula:  (n >> i) & 1



ğŸŸ¢ 3ï¸âƒ£ Set the ith bit to 1

ğŸ§© Formula: n | (1 << i)



ğŸŸ¢ 4ï¸âƒ£ Clear the ith bit (make it 0)

ğŸ§© Formula: n & ~(1 << i)


ğŸŸ¢ 5ï¸âƒ£ Toggle (Flip) the ith bit

ğŸ§© Formula: n ^ (1 << i)




ğŸŸ¢ 6ï¸âƒ£ Count number of set bits (1s)

def count_set_bits(n):
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count

print(count_set_bits(13))  # 3


Brian Kernighanâ€™s Trick (Faster ğŸ”¥)

Every iteration removes the rightmost 1-bit:

def count_set_bits(n):
    count = 0
    while n:
        n &= n - 1
        count += 1
    return count

print(count_set_bits(13))  # 3





ğŸŸ¢ 7ï¸âƒ£ Check if a number is power of 2

A number is power of 2 if only one bit is set.

ğŸ§© Formula: n > 0 and (n & (n - 1)) == 0




ğŸŸ¢ 8ï¸âƒ£ Swap two numbers without temp variable
a = 5
b = 7
a = a ^ b
b = a ^ b
a = a ^ b
print(a, b)  # 7 5



ğŸŸ¢ 9ï¸âƒ£ Find single unique number (All others appear twice)

arr = [2, 3, 5, 3, 2]
unique = 0
for num in arr:
    unique ^= num
print(unique)  # 5

ğŸ’¡ Because x ^ x = 0 and x ^ 0 = x.



ğŸŸ¢ ğŸ”Ÿ Convert to binary manually (for understanding)

def to_binary(n):
    res = ''
    while n:
        res = str(n & 1) + res
        n >>= 1
    return res or '0'

print(to_binary(13))  # '1101'








ğŸ§© Step 4: Practice Exercises (for beginners)

Try to solve these one by one:

Check if kth bit is set or not

Toggle all bits of a number

Count total set bits from 1 to N

Reverse bits of a number (e.g., 13 â†’ 1011 â†’ 1101 â†’ 11)

Find 2 unique numbers where every other appears twice

Add two numbers using bitwise operators (without +)



| Problem Type           | Example                                   |
| ---------------------- | ----------------------------------------- |
| Subsets / Combinations | Use bits to represent inclusion/exclusion |
| Optimization           | Faster arithmetic / toggling              |
| DP with masks          | â€œTravelling salesmanâ€, â€œSubset sumâ€       |
| Math tricks            | Check power of 2, parity, etc.            |
